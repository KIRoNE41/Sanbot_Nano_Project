#!/usr/bin/env python3
# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer
import threading
import rclpy
from rclpy.node import Node
from custom_msg_srv.msg import String

from custom_msg_srv.srv import Control
from custom_msg_srv.srv import Direction

import subprocess as sp
import cv2
import time
import serial 

NODE = None
GUI = None
send = ""
last_send = ""
data = ""
stopfunc = False
class MyNode(Node):
    
    def __init__(self):
        super().__init__('py_ai_follow_node')
        #        self.srv_gui_client = self.create_client(srv_type=Control,srv_name="/control/send_message")
#        while not self.srv_gui_client.wait_for_service(timeout_sec=1.0) and stoprun == False:
#            self.get_logger().info("Waiting for service /control/send_message")
        
        self.srv_ai_follow_direction_client = self.create_client(srv_type=Direction,srv_name="/direction/send_message")
        while not self.srv_ai_follow_direction_client.wait_for_service(timeout_sec=1.0) and stopfunc == False:
            self.get_logger().info("Waiting for service /direction/send_message")
            
        self.create_subscription(msg_type=String,topic="/control_topic",callback=self.callback_control,qos_profile=10)
    
        self.create_subscription(msg_type=String,topic="/command_topic",callback=self.close_node,qos_profile=10)
    
    def close_node(self,msg:String):
        global data
        data = msg.msg
        self.get_logger().info(msg.msg)

    def call_srv_direction_client(self,direction:str):
        request = Direction.Request()
        request.direction = direction
        self.srv_ai_follow_direction_client.call_async(request=request)
        
#    def call_srv_client(self,direction:str,speed:int):
#        global last_send
#        global send
#        send = str(direction+":"+str(speed))
#        if send != last_send:
#            request = Control.Request()
#            request.direction = direction
#            request.speed = speed
#            self.srv_gui_client.call_async(request=request)
#            last_send = send

#        elif send == last_send:
#            pass

    def callback_control(self,msg:String):
       	self.get_logger().info(msg.msg)

patch_student = '/home/pi/AI_path/student_cascade.xml'  # PATH OF THE CASCADE
patch_upperbody = '/home/pi/AI_path/haarcascade_upperbody2.xml'
patch_face = '/home/pi/AI_path/haarcascade_frontalface_default.xml'
cameraNo = '/dev/video0'#   0||'/dev/video0'  # CAMERA NUMBER
#cameraNo2 = 1
objectName = 'Student'  # OBJECT NAME TO DISPLAY
objectName2 = 'Body'
objectName3 = 'face'
frameWidth = 256  # DISPLAY WIDTH
frameHeight = 192  # DISPLAY HEIGHT
color = (255, 0, 0)  # Blue
color2 = (0, 255, 0)  # Green
color3 = (0, 0, 255)  # Red
cap = cv2.VideoCapture(cameraNo)######
# cap2 = cv2.VideoCapture(cameraNo2)#####
#arduino = serial.Serial(port='/dev/ttyACM0', baudrate=115200, timeout=.1) 
last_x = None
def empty(a):
    pass
#def write_read(x): #def write_read(x): 
#    global last_x
#    if x != last_x:
#        arduino.write(bytes(x, 'utf-8') )#
#        time.sleep(0.05) 
#        data = arduino.readline() 
#        print(x)
#        last_x = x
#        return data 
#    elif x == last_x:
#        pass
    

#def Result():
#    cv2.namedWindow("Result")
#    cv2.resizeWindow("Result", frameWidth, frameHeight + 100)
#    cv2.createTrackbar("Scale_1", "Result", 400, 1000, empty)
#    cv2.createTrackbar("Neig_1", "Result", 8, 50, empty)
#    cv2.createTrackbar("Min Area_1", "Result", 0, 100000, empty)
#
#    cv2.createTrackbar("Scale_2", "Result", 400, 1000, empty)
#    cv2.createTrackbar("Neig_2", "Result", 8, 50, empty)
#    cv2.createTrackbar("Min Area_2", "Result", 0, 100000, empty)
#
#    cv2.createTrackbar("Scale_3", "Result", 400, 1000, empty)
#    cv2.createTrackbar("Neig_3", "Result", 8, 50, empty)
#    cv2.createTrackbar("Min Area_3", "Result", 0, 100000, empty)
#
#    cv2.createTrackbar("Brightness_1", "Result", 180, 255, empty)

def AIFollow():
    # CREATE TRACKBAR
    # LoadPage()
    #time.sleep(1)
    global data
    global stopfunc
    #Result()
    # LOAD THE CLASSIFIERS DOWNLOADED
    cascade_student = cv2.CascadeClassifier(patch_student)
    cascade_upperbody = cv2.CascadeClassifier(patch_upperbody)
    cascade_face = cv2.CascadeClassifier(patch_face)
    stopfunc = False
    human = False
    student = False
    pose = "None"
    dataAIF = ""
    lastdataAIF = ""
    NODE = MyNode()
    NODE.get_logger().info("Open")
    while True:
        
        # ---------------------     -------------------------------------------
        # SET CAMERA BRIGHTNESS FROM TRACKBAR VALUE
        #cameraBrightness = cv2.getTrackbarPos("Brightness_1", "Result")
        cap.set(10, 10)
        # GET CAMERA IMAGE AND CONVERT TO GRAYSCALE
        success, img = cap.read()
        img = cv2.resize(img, (frameWidth, frameHeight))

        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        # DETECT THE OBJECT USING THE CASCADE
        #scaleVal = 1 + (cv2.getTrackbarPos("Scale_1", "Result") / 1000)
        #neig = cv2.getTrackbarPos("Neig_1", "Result")

        #scaleVal2 = 1 + (cv2.getTrackbarPos("Scale_2", "Result") / 1000)
        #neig2 = cv2.getTrackbarPos("Neig_2", "Result")

        #scaleVal3 = 1 + (cv2.getTrackbarPos("Scale_3", "Result") / 1000)
        #neig3 = cv2.getTrackbarPos("Neig_3", "Result")

        #objects = cascade_student.detectMultiScale(gray, scaleVal, neig)
        #objects2 = cascade_upperbody.detectMultiScale(gray, scaleFactor=1.3,
                                                      #minNeighbors=2)  # scaleFactor = 1.3, minNeighbors = 2 / scaleVal2, neig2
        objects3 = cascade_face.detectMultiScale(gray, 1.2, 4)
        # ----------------------------------------------------------------
        # DISPLAY THE DETECTED OBJECTS
        #num = 0
        #num2 = 0
        num3 = 0
        dataAIF  = "Stop"
        #NODE.call_srv_client(direction="Stop",speed=20)
        
        for (xf, yf, wf, hf) in objects3:  # inFace
            areaf = wf * hf
            #minAreaf = cv2.getTrackbarPos("Min Area_3", "Result")
            if areaf > 10:
                cenx = int(xf + (wf * 0.5))
                ceny = int(yf + (hf * 0.5))
                cv2.rectangle(img, (xf, yf), (xf + wf, yf + hf), color3, 3)
                cv2.circle(img, (cenx, ceny), 5, (0, 255, 0), -1)
                # roi_colorf = img[yf:yf+hf, xf:xf+wf]
                num3 += 1
                human = True
                print("Position PosX:" + str(cenx) + " PosY" + str(ceny))
                if cenx < frameWidth * (1/5):
                    #print("You Left PLS Right")
                    dataAIF = "TrunLeft"
                    #write_read(dataAIF)
                    NODE.call_srv_direction_client(direction=dataAIF)
                    time.sleep(0.1)
                if cenx > frameWidth * (1/5) and cenx < frameWidth * (2/5) :
                    #print("You Left PLS Right")
                    dataAIF = "TrunLeft"
                    #write_read(dataAIF)
                    NODE.call_srv_direction_client(direction=dataAIF)
                    time.sleep(0.1)
                if cenx > frameWidth * (4/5):
                    #print('You Rigth PLS Left')
                    dataAIF = "TrunRight"
                    #write_read(dataAIF)
                    NODE.call_srv_direction_client(direction=dataAIF)
                    time.sleep(0.1)
                if cenx < frameWidth * (4/5) and cenx > frameWidth * (3/5) :
                   # print('You Rigth PLS Left')
                    dataAIF = "TrunRight"
                    #write_read(dataAIF)
                    NODE.call_srv_direction_client(direction=dataAIF)
                    time.sleep(0.1)
                if cenx > frameWidth * (2/5) and cenx < frameWidth * (3/5):
                    dataAIF = "Forward"
                    #write_read(dataAIF)
                    NODE.call_srv_direction_client(direction=dataAIF)
                    # print(dataAIF)
                    time.sleep(0.1)
            else:
                dataAIF  = "Stop"
                #write_read(dataAIF)
                NODE.call_srv_direction_client(direction=dataAIF)
                # time.sleep(0.1)
        NODE.call_srv_direction_client(direction=dataAIF)
        cv2.line(img=img, pt1=(int((frameWidth / 5) * 1 ), 0), pt2=(int((frameWidth / 5) * 1), int(frameHeight)),
                 color=(0, 255, 255), thickness=2, lineType=8, shift=0)
        cv2.line(img=img, pt1=(int((frameWidth / 5) * 2 ), 0), pt2=(int((frameWidth / 5) * 2), int(frameHeight)),
                 color=(0, 255, 255), thickness=2, lineType=8, shift=0)
        cv2.line(img=img, pt1=(int((frameWidth / 5) * 3), 0), pt2=(int((frameWidth / 5) * 3), int(frameHeight)),
                 color=(0, 255, 255), thickness=2, lineType=8, shift=0)
        cv2.line(img=img, pt1=(int((frameWidth / 5) * 4), 0), pt2=(int((frameWidth / 5) * 4), int(frameHeight)),
                 color=(0, 255, 255), thickness=2, lineType=8, shift=0)
        
        # cv2.rectangle(,,,color3,3)
        #count = "Student = " + str(num)
        #cv2.putText(img, count, (0, 30), cv2.FONT_HERSHEY_COMPLEX_SMALL, 1, (255, 0, 0), 1)
        #count2 = "upperbody= " + str(num2)
        #cv2.putText(img, count2, (0, 60), cv2.FONT_HERSHEY_COMPLEX_SMALL, 1, (255, 0, 0), 1)
        count3 = "face= " + str(num3)
        cv2.putText(img, count3, (0, 90), cv2.FONT_HERSHEY_COMPLEX_SMALL, 1, (255, 0, 0), 1)

        cv2.imshow("AI", img)
        # win.mainloop()
        if (cv2.waitKey(1) & 0xFF == ord('q')) or stopfunc == True or data =="AI_Follow close":
            # Break()
            # cv2.destroyAllWindows()
            #dataAIF  = "#Stop:20;"
            #write_read(dataAIF)
            NODE.call_srv_direction_client(direction="Stop")
            NODE.get_logger().info("Stop")
            #NODE.destroy_node()
            break
    cap.release()
    cv2.destroyAllWindows()
def main():
    rclpy.init()
    
    NODE = MyNode()
    thread_spin = threading.Thread(target=rclpy.spin,args=(NODE, ))
    thread_spin.start()

    AIFollow()
    
    NODE.destroy_node()
    rclpy.shutdown()
    thread_spin.join()
    
if __name__ == '__main__':
	main()
    
